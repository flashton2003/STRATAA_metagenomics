library(dplyr)
library(edgeR)
library(ggplot2)
library(magrittr)
library(microbiome)
library(phyloseq)
library(readr)
library(reshape2)
library(rlist)
library(stringr)
library(tidyr)
library(vegan)
library(VennDiagram)
library(Maaslin2)


#source("/Users/flashton/Dropbox/GordonGroup/STRATAA_Microbiome/from_Leo/Leonardos_analysis/bin/config.R")

read_metadata <- function(path_to_metadata){
  meta <- read.csv(path_to_metadata, header=T, sep = "\t")
  # i dont think this line does anything, probably just there for historic reasons
  names(meta)[names(meta) == "sample_ID"] <- "isolate"
  names(meta)[names(meta) == "ID"] <- "isolate"
  meta <- meta %>% mutate(age_bracket=cut(Age, breaks=c(0, 1, 5, 15, Inf), labels=c("0-1", "1-5", "6-15", ">15")))
  meta$group_country <- paste(meta$Group, meta$Country, sep = '_')
  meta$group_antibiotic <- paste(meta$Group, meta$Antibiotics_taken_before_sampling_yes_no_assumptions, sep = '_')
  
  return(meta)
}


get_baseline_characteristics <- function(meta){
  meta_subset <- meta %>% select(Group, Sex, Country, Age, Antibiotics_taken_before_sampling_yes_no_assumptions)
  
  pct_female <- meta_subset %>% group_by(Group, Country, Sex) %>% summarise(n = n()) %>% pivot_wider(names_from = c(Sex), values_from = n) %>% mutate(pct_fem = (Female / sum(c(Female, Male))) * 100) %>% select(c(Group, Country, pct_fem))
  
  pct_antibiotics <- meta_subset %>% group_by(Group, Country, Antibiotics_taken_before_sampling_yes_no_assumptions) %>% summarise(n = n()) %>% pivot_wider(names_from = c(Antibiotics_taken_before_sampling_yes_no_assumptions), values_from = n)
  pct_antibiotics[is.na(pct_antibiotics)] <- 0
  pct_antibiotics <- pct_antibiotics %>% mutate(pct_anti = (Yes / sum(c(No, Yes, Unknown))) * 100) %>% select(c(Group, Country, pct_anti))
  
  baseline_chars <- meta_subset %>% group_by(Country, Group) %>% summarise(number = n(), median_age = median(Age)) %>% left_join(pct_female, by = c('Group', 'Country')) %>% left_join(pct_antibiotics, by = c('Group', 'Country'))
  return(baseline_chars)
}


remove_rare <- function( table , cutoff_pro ) {
  row2keep <- c()
  cutoff <- ceiling( cutoff_pro * ncol(table) )  
  for ( i in 1:nrow(table) ) {
    row_nonzero <- length( which( table[ i , ]  > 0 ) ) 
    if ( row_nonzero > cutoff ) {
      row2keep <- c( row2keep , i)
    }
  }
  return( table [ row2keep , , drop=F ])
}


run_make_filtered_otu_table <- function(output_folder, tax_level, countries, filename_regex, braken_folder, meta){
  species_dir <- file.path(output_folder, '1_species')
  alpha_dir <- file.path(output_folder, '3_alpha')
  
  if (!dir.exists(output_folder)){ dir.create(output_folder) }
  if (!dir.exists(species_dir)){ dir.create(species_dir) }
  if (!dir.exists(alpha_dir)){ dir.create(alpha_dir) }
  
  samples_to_include <- meta %>% filter(Country %in% countries) %>% select('isolate')
  samples_to_include <- samples_to_include$isolate
  #View(samples_to_include)
  filtered_otu.unnormalised <- make_filtered_otu_table(braken_folder, tax_level, filename_regex, output_folder, samples_to_include)
  # not needed at the moment, but leaving in just in case
  #colnames(filtered_otu.unnormalised) = gsub(pattern = "X", replacement = "", x = colnames(data_table.unnormalised))
  return(filtered_otu.unnormalised)
}


make_filtered_otu_table <- function(braken_folder, taxonomic_level, filename_regex, output_folder, samples_to_include){
  #browser()
  output_folder <- file.path(output_folder, paste('1_', taxonomic_level, sep = ""))
  #create the names of the parsed bracken files - one with all the data and one with the filtered
  summary_file <- file.path(output_folder, paste("summarised_", taxonomic_level, "_kraken.txt", sep = ""))
  otu_file <- file.path(output_folder, paste("summarised_", taxonomic_level, "_otu.txt", sep = ""))
  filtered_otu_file <- file.path(output_folder, paste("summarised_filtered_", taxonomic_level, "_otu.txt", sep = ""))

  #if the filtered data exists, load it and exit
  if (file.exists(filtered_otu_file)){
    filtered_otu <- read.csv(filtered_otu_file, header=T, sep = "\t")
    return(filtered_otu)
  }
  
  #read the bracken output and put it in 1 file
  combined_bracken <- combine_bracken_outputs(braken_folder, filename_regex, samples_to_include, taxonomic_level)
  write.table(combined_bracken, summary_file, row.names = F, quote=FALSE, sep='\t')
  
  #create the otu matrix
  otu <- data.frame(acast(combined_bracken, name ~ sample_ID, value.var = "kraken_assigned_reads", fill=0))
  colnames(otu) = gsub(pattern = "X", replacement = "", x = colnames(otu))
  write.table(otu, otu_file, row.names = T, quote=FALSE, sep='\t')
  
  pdf(file = file.path(output_folder, paste(taxonomic_level, "_abundances_hist.pdf", sep = "")))
  hist(as.matrix(otu), 
       breaks = 100, 
       main="Histogram For Unfiltered OTU table", 
       xlab="Relative Abundance", 
       border="blue")
  dev.off()
  
  #old filtering method
  #data <- data %>% filter(fraction_total_reads > 0.002)
  
  #filter: remove OTUs that have non-zero values in <= 10% of samples
  # pa - this is equivalent to removing SNPs with low allele threshold in a GWAS
  filtered_otu <- remove_rare(table=otu, cutoff_pro=0.1)
  colnames(filtered_otu) = gsub(pattern = "X", replacement = "", x = colnames(filtered_otu))
  write.table(filtered_otu, filtered_otu_file, row.names = T, quote=FALSE, sep='\t')
  
  otu_table_rare_removed_norm_cpm <- sweep(filtered_otu, 2, colSums(filtered_otu) , '/')*100
  
  pdf(file = file.path(output_folder, paste(taxonomic_level, "_filtered_abundances_hist.pdf", sep = ""))) 
  hist(as.matrix(otu_table_rare_removed_norm_cpm), 
       main="Histogram For filtered OTU table", 
       breaks = 100, 
       xlab="Relative Abundance", 
       border="blue")
  dev.off()
  return(filtered_otu)
}


combine_bracken_outputs <- function(braken_folder, filename_regex, samples_to_include, tax_level){
  # compile all reports
  bracken_reports_files <- list.files(braken_folder, full.names = T)
  
  combined_bracken <- NULL
  for (sample in samples_to_include){
    file_handle <- file.path(braken_folder, tax_level, paste(sample, '_R1.bracken', sep = ''))
    print(file_handle)
    file_info <- file.info(file_handle)
    # if the file contains data then add it to the combined table
    if (file_info$size > 99){
      bracken_reports_file <- read_tsv(file_handle)
      #browser()
      #here change the reg expr to match the sample names
      name <- str_extract(rownames(file_info), filename_regex)
      bracken_reports_file$sample_ID <- name
      combined_bracken <- rbind(combined_bracken, bracken_reports_file)
    }
  }
  return(combined_bracken)
}


calculate_beta <- function(data, meta, output_folder){
  #make the first column headers
  rownames(meta) <- meta[,1]
  #meta <- meta %>% remove_rownames %>% column_to_rownames()
  
  #and order
  meta <- meta[ order(row.names(meta)), ]
  # need to transpose the OTU table from species as rows to species as columns
  data <- as.matrix(t(data))
  #order data table as well to be sure
  data <- data[ order(row.names(data)), ]
  rownames(data) <- gsub("#","_",rownames(data))
  rownames(data) <- gsub("X","",rownames(data))
  #make sure that you have the same ids
  meta_names <- rownames(meta)
  data_names <- rownames(data)
  common.ids <- intersect(rownames(meta), rownames(data))
  #browser()
  #make sure you have the correct meta
  meta <- meta[common.ids,]
  data <- data[common.ids,]
  
  #transform the table to relative abundances
  data <- sweep(data, 1, rowSums(data),'/')
  #calculate bray curtis distance matrix
  d.bray <- vegdist(data)
  
  #transform it to a matrix to save it
  beta_matrix <- as.matrix(d.bray)
  #View(beta_matrix)
  #Perform PCoA
  pc.bray <- cmdscale(d.bray, k=4, eig = T)
  pcoa.var <- round(pc.bray$eig/sum(pc.bray$eig)*100, 1)
  pcoa.values <- pc.bray$points
  pcoa.data <- data.frame(Sample = rownames(pcoa.values), X=pcoa.values[,1], Y = pcoa.values[,2])
  #pcoa.data <- data.frame(X=pcoa.values[,1], Y = pcoa.values[,2])
  
  if (!dir.exists(output_folder)){ dir.create(output_folder) }
  
  #save the table
  pairwise_out_file <-  file.path(output_folder, "pairwise_beta.txt")
  first_2d_coords_out_file <- file.path(output_folder, "first_2d_coords.txt")
  pcoa_var_file <- file.path(output_folder, "pcoa_var.txt")
  write_delim(as.data.frame(beta_matrix), pairwise_out_file)
  #write.table(beta_matrix, pairwise_out_file, row.names=T, col.names=T, sep = "\t")
  write_delim(as.data.frame(pcoa.data), first_2d_coords_out_file)
  #write.table(pcoa.data, first_2d_coords_out_file, col.names = T, sep = "\t")
  write_delim(as.data.frame(pcoa.var), pcoa_var_file)
  output <- list(pcoa.data = pcoa.data, pcoa.var = pcoa.var)
  saveRDS(d.bray, file.path(output_folder, 'd.bray.RDS'))
  saveRDS(meta, file.path(output_folder, 'meta_for_permanova.RDS'))
  
}


plot_beta <- function(pcoa.data, pcoa.var, to_plot){
  #plot and save
  #file_path <- paste(output_folder, prefix, "_beta_PCoA.pdf", sep = "")
  #get the metadata column to paint the plot
  output_plots <- list()
  if ("Country" %in% to_plot) {
    country_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = Country)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Country")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    
    
    output_plots <- list.append(output_plots, "country_plot" = country_plot)
  }
  
  if ("Group" %in% to_plot) {
    group_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = Group)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Group")) +
      geom_point() #+
      #coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    output_plots <- list.append(output_plots, "group_plot" = group_plot)
  }
  
  if ("Sex" %in% to_plot) {
    sex_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = Sex)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Sex")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    output_plots <- list.append(output_plots, "sex_plot" = sex_plot)
  }
  
  if ("age_bracket" %in% to_plot) {
    age_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = age_bracket)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Age bracket")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    output_plots <- list.append(output_plots, "age_plot" = age_plot)
  }
  
  if ("group_country" %in% to_plot) {
    group_country_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = group_country)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Group/Country")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    output_plots <- list.append(output_plots, "group_country_plot" = group_country_plot)
  }
  
  if ("group_antibiotic" %in% to_plot) {
    group_antibiotic_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = group_antibiotic)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="Group/Antibiotic")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
    output_plots <- list.append(output_plots, "group_antibiotic_plot" = group_antibiotic_plot)
  }
    
  if ("sequencing_lane" %in% to_plot) {
    sequencing_lane_plot <- ggplot(pcoa.data, aes(x=X, y=Y, colour = sequencing_lane)) + 
      xlab(paste("MDS1 - ", pcoa.var[[1]][1], "%", sep="")) + 
      ylab(paste("MDS2 - ", pcoa.var[[1]][2], "%", sep="")) + 
      guides(colour=guide_legend(title="sequencing_lane")) +
      geom_point() +
      coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5))
  output_plots <- list.append(output_plots, "sequencing_lane" = sequencing_lane_plot)
  }
  
  
  #+
    #theme(legend.position="none")
  #+ geom_text(aes(label=Sample),hjust=0, vjust=0)
  #g1 <- ggplot(pcoa.data, aes(x=X, y=Y)) + 
  #  ggtitle(title) + xlab(paste("MDS1 - ", pcoa.var[1], "%", sep="")) + ylab(paste("MDS2 - ", pcoa.var[2], "%", sep="")) + 
  #  geom_point() #+ geom_text(aes(label=Sample),hjust=0, vjust=0)
  #ggsave(file_path)
  #print(g1)
  return(output_plots)
}


calculate_alpha <- function(data, meta, group, output_folder, prefix, inc_country){
  
  #calculate alpha diverities 
  #input_matrix <- acast(data, sample_ID ~ name, value.var = summary_column, fill=0)
  #View(data)
  data <- t(data)
  
  
  #make the first column headers
  rownames(meta) <- meta[,1]
  #meta <- meta %>% remove_rownames %>% column_to_rownames()
  
  #and order
  meta <- meta[ order(row.names(meta)), ]
  
  #order data table as well to be sure
  data <- data[ order(row.names(data)), ]
  rownames(data) <- gsub("#","_",rownames(data))
  rownames(data) <- gsub("X","",rownames(data))
  #make sure that you have the same ids
  meta_names <- rownames(meta)
  data_names <- rownames(data)
  #View(meta_names)
  #View(data_names)
  common.ids <- intersect(rownames(meta), rownames(data))
  #View(common.ids)
  #browser()
  #make sure you have the correct meta
  meta <- meta[common.ids,]
  data <- data[common.ids,]
  
  alpha <- vegan::diversity(data, index="shannon")
  
  if (isTRUE(inc_country)) {
    s <- summary(aov(alpha ~ Country * Sex *Group * age_bracket * Antibiotics_taken_before_sampling_yes_no_assumptions, data = meta))
  } else {
    s <- summary(aov(alpha ~ Sex *Group * age_bracket * Antibiotics_taken_before_sampling_yes_no_assumptions, data = meta))
  }
  
  

  
  alpha_table <- tibble(isolate = names(alpha), alpha = alpha)
  #View(alpha_table)
  #alpha_table <- alpha_table %>% mutate(isolate = substring(isolate, 2))
  #View(meta)
  #View(alpha_table)
  #alpha_table <- left_join(meta, alpha_table, by="isolate")
  #View(alpha_table)
  
  #for t.test
  #all pairwise combinations
  #print(group)
  #print(meta[,eval(group)])
  #print(levels(meta[,eval(group)]))
  #my_comparisons <- combn(levels(meta[,eval(meta$Group)]), 2, simplify = F)
  
  #pairwise t test
  f <- paste("alpha~", group, sep = "")
  #pv <- compare_means(as.formula(f),  data = alpha_table, method = "t.test")
  
  #gr <- pv$p <= 0.05
  
  write_delim(alpha_table, file.path(output_folder, "3_alpha", "shannon.alpha_results.tsv"))
  #output_folder <- paste(output_folder, "3_alpha/", sep = "")
  #if (!dir.exists(output_folder)){ dir.create(output_folder) }
  
  title <- paste("Alpha div.(T test): ", prefix, sep = "")
  
  
  alpha_table <- alpha_table %>% filter(!is.na(alpha))

  
  return(s)
}


calculate_dge <- function(our_metadata, output_folder, tax_level, otu, covariates, groups_for_comparison){
  # manipulate full_meta
  rownames(our_metadata) <- our_metadata[,1]
  sampledata <- sample_data(our_metadata)

  #otu <- read.csv(otu_file, header=T, row.names=1, sep = "\t")
  colnames(otu) = gsub(pattern = "X", replacement = "", x = colnames(otu)) 
  OTU = otu_table(otu, taxa_are_rows = TRUE)
  
  #put them in a phyloseq object
  OTU <- t(OTU)
  pseq <- phyloseq(OTU, sampledata)
  our_metadata <- meta(pseq)
  otu <- abundances(pseq)
  
  # need to filter out the samples that aren't included in the comparison
  # this is the old way of doing it, but subset_samples can't take variables as arguments (!)
  #pseq_control_vs_acute <- subset_samples(pseq, Group == group1_for_comp | Group == group2)
  # see below link for old bug report and work around
  # https://github.com/joey711/phyloseq/issues/335
  # take the pseq sample data
  var_values <- sample_data(pseq)
  # make a boolean of the length sample_data(pseq) that evaluates whether the Group is in the groups to be compared
  var_bool <- var_values$Group %in% groups_for_comparison
  # use this boolean to prune the pseq object samples
  # i've checked, and this gives equivalent results to the previous way of doing it.
  pseq_control_vs_acute <- prune_samples(var_bool, pseq)
  subset_meta <- meta(pseq_control_vs_acute)
  #View(subset_meta)
  subset_otu <- t(abundances(pseq_control_vs_acute))
  # this is Leo's function for running edgeR GLM.
  result <- glm_edgeR(x=subset_meta$Group, Y=subset_otu, covariates = subset_meta[ , covariates])
  #result <- glm.edgeR(x=subset_meta$Group, Y=subset_otu)
  topTags(result, n=10)
  dge_out_folder <- file.path(output_folder,'5_glm')
  if (!dir.exists(dge_out_folder)){ dir.create(dge_out_folder) }
  covar_initials <- paste(str_sub(covars, 1, 6), sep = '', collapse = '')
  write.table(topTags(result, n=Inf)$table, file=file.path(dge_out_folder, paste('results_all', paste(groups_for_comparison[1], 'vs', groups_for_comparison[2], sep = '_'), covar_initials, 'edgeR.tsv', sep = '.')), sep='\t',quote=FALSE, col.names=NA)
}


glm_edgeR <- function(x, Y, covariates=NULL,use.fdr=TRUE, estimate.trended.disp=TRUE,verbose=TRUE) {
  # x is the independent variable
  # Y is a matrix of samples x dependent variables
  # x is the Group
  # y is the OTU
  # returns p-values
  # drop samples that are NA for, by default, the Group (i.e. acute typhi/healthy control/etc)
  ix <- !is.na(x)
  Y <- Y[ix,]
  x <- x[ix]
  # if covariates have been given
  if(!is.null(covariates)){
    # if the dimensions of them are null then it isn't a matrix/data frame, so convert it to one
    if(is.null(dim(covariates))){
      covariates <- as.data.frame(covariates)
    }
    # drop samples that are NA for the independent variable
    covariates <- covariates[ix,,drop=F]
    
    # drop constant covariates
    covariates <- covariates[,apply(covariates,2,function(xx) length(unique(xx)) > 1),drop=F]
  }
  
  if(verbose) cat('Making DGEList...\n')
  d <- DGEList(count=t(Y), group=x)
  View(d)
  if(verbose) cat('calcNormFactors...\n')
  d <- calcNormFactors(d, method = "TMM" )
  if(!is.null(covariates)){
    covariates <- as.data.frame(covariates)
    # combines the Group (i.e. acute typhi etc) back with the co-variates
    covariates <- cbind(x, covariates)
    covariates <- droplevels(covariates)
    design <- model.matrix(~ ., data=covariates)
    # this makes the below
    # x <- data.frame(c('case', 'control', 'carrier'), c(5, 17, 8))
    # model.matrix(~ ., data = x)
    #  (Intercept) c..case....control....carrier..case c..case....control....carrier..control c.5..17..8.
    # 1           1                                   1                                      0           5
    # 2           1                                   0                                      1          17
    # 3           1                                   0                                      0           8
  } else {
    design <- model.matrix(~x)
  }
  
  if(verbose) cat('estimate common dispersion...\n')
  d <- estimateGLMCommonDisp(d, design)
  if(estimate.trended.disp){
    if(verbose) cat('estimate trended dispersion...\n')
    d <- estimateGLMTrendedDisp(d, design)
  }
  if(verbose) cat('estimate tagwise dispersion...\n')
  d <- estimateGLMTagwiseDisp(d,design)
  
  if(verbose) cat('fit glm...\n')
  fit <- glmFit(d,design)
  if(verbose) cat('likelihood ratio test...\n')
  lrt <- glmLRT(fit,coef=2)
  
  return(lrt)
}


combine_and_compare_edgeRs <- function(to_combine, location_names){
  #View(to_combine)
  print(length(to_combine))
  if (length(to_combine) == 2) {
    combined_dpt <- left_join(to_combine[[1]], to_combine[[2]], by = 'species', suffix = location_names[1:2])
  }
  else {
    print('combine_and_compare_edgeRs only setup for combining 2 dfs right now')
    quit()
  }
  #if (length(to_combine) == 3) {
  #  combined_dpt <- left_join(to_combine[[1]], to_combine[[2]], by = 'species', suffix = location_names[1:2])
  #  combined_dpt <- left_join(combined_dpt, to_combine[[3]], by = 'species', suffix = c(NA, location_names[3]))
  #}
  
  # across selects all the columns that start with FDR, and combined with the filter, selects only rows with FDR < 0.05
  # i'm not really sure what the ~ .x is about though?
  sig <- combined_dpt %>% filter(across(starts_with('FDR'), ~ .x < 0.05))
  sig_up <- sig %>% filter(across(starts_with('logFC'), ~ .x >= 1))
  sig_down <- sig %>% filter(across(starts_with('logFC'), ~ .x <= -1))
  View(sig_up)
  View(sig_down)
  #venn.diagram(x = list(bangladesh_dpt$species, malawi_dpt$species, nepal_dpt$species), category.names = c('Bangladesh', 'Malawi', 'Nepal'), filename = file.path(combined_output_folder, paste(the_date, comp, covar_initials, 'venn_diagram.no_filter.png', sep = '.')), euler.d = FALSE, scaled = FALSE, height=2200, width=2200)
  #print(paste('Jaccard of unfiltered taxa of Bang, Mal, Nep = ', jaccard(bangladesh_dpt$species, malawi_dpt$species, nepal_dpt$species)), sep = '')
  output <- list(sig_up = sig_up, sig_down = sig_down)
  return(output)
}

make_name <- function(output_folder, covars, comp){
  dge_out_folder <- file.path(output_folder,'5_glm')
  covar_initials <- paste(str_sub(covars, 1, 6), sep = '', collapse = '')
  name=file.path(dge_out_folder, paste('results_all', comp, covar_initials, 'edgeR.tsv', sep = '.'))
  return(name)
}

jaccard <- function(input_1, input_2, input_3){
  intersection = length(intersect(intersect(input_1, input_2), input_3))
  union = length(union(union(input_1, input_2), input_3))
  return (intersection/union)
}

# add a fucntion make_clean to take in the maaslin_prevalence and 
# make it into a clean table

make_clean <- function(maaslin_prevalence, variable) {
  # Filter the maaslin_prevalence by variable
  maaslin_filtered <- maaslin_prevalence %>% 
    filter(variable == {{ variable }})
  
  # Select the columns that aren't NA for that variable
  maaslin_clean <- maaslin_filtered %>% 
    select_if(~ !all(is.na(.)))
  # View(maaslin_clean)
  # Combine the last four columns into a single string column
  maaslin_clean <- maaslin_clean %>% 
    unite("prevalence", -c(1:2), sep = ";", na.rm = TRUE)
  # View(maaslin_clean)
  # Return the clean data frame
  return(maaslin_clean)
}

run_make_clean <- function(maaslin_prevalence) {
  # this function runs make_clean for different variables
  # and then combines the output into a single data frame
  group_clean <- make_clean(maaslin_prevalence, variable = "Group")
  sex_clean <- make_clean(maaslin_prevalence, variable = "Sex")
  antibiotics_clean <- make_clean(maaslin_prevalence, variable = "Antibiotics_taken_before_sampling_yes_no_assumptions")
  clean_output <- rbind(group_clean, sex_clean, antibiotics_clean)
  View(clean_output)
  return(clean_output)
}

add_prevalence_to_maaslin_output <- function(output_dir, prevalence) {
  # Load the MaAsLin output file
  maaslin_output <- read_tsv(file.path(output_dir, "all_results.tsv"))
  # rename the feature values in the maaslin output and the prevalence (from the metaphlan output) - annoying, not sure why this needed to be done.
  maaslin_output <- maaslin_output %>% mutate(feature = str_replace_all(feature, "\\.", "_"))
  prevalence <- prevalence %>% mutate(feature = str_replace_all(feature, "\\|", "_"))
  
  # Pivot the prevalence data frame to make it wider - each row now contains the median prevalence for each feature in each sample for each variable
  prevalence_wider <- prevalence %>% 
    pivot_wider(names_from = value, values_from = Median_Prevalence)
  # View(prevalence_wider)
  # get the clean prevalence data frame, which contains the prevalence in the two different groups for each variable separated by semi-colons
  clean_prevalence <- run_make_clean(prevalence_wider)
  # Join the MaAsLin output file with the metadata
  maaslin_prevalence <- maaslin_output %>% 
    left_join(clean_prevalence, by = join_by("feature" == "feature", "metadata" == "variable"))
  # View(maaslin_prevalence)
  
  # Write the prevalence data frame to a file
  write_tsv(maaslin_prevalence, file.path(output_dir, "all_results.prevalence.tsv"))
}

calculate_prevalence <- function(feature_data, metadata, country, groups_for_analysis, variables_for_analysis) {
  
  # Filter the metadata to get the correct country and groups for analysis
  metadata_filtered <- metadata %>% 
    filter(Country == country, Group %in% groups_for_analysis)
  # set SampleID column instead of rownames.
  metadata_filtered <- metadata_filtered %>% 
    mutate(SampleID = rownames(metadata_filtered))
  rownames(metadata_filtered) <- NULL
  # for the feature data as well
  feature_data <- feature_data %>% 
    mutate(feature = rownames(feature_data))
  rownames(feature_data) <- NULL
  # feature data is in a square matrix, so pivot it to long format
  feature_data <- feature_data %>% 
    pivot_longer(cols = -feature, names_to = "SampleID", values_to = "prevalence")
  
  # Join the feature data with the metadata
  # remove everything with NA for group, these are things from the feature data that aren't in the filtered metadata
  feature_metadata <- feature_data %>% 
    left_join(metadata_filtered, by = "SampleID") %>% filter(!is.na(Group))
  # View(feature_metadata)
  # Remove the columns that aren't needed
  feature_metadata <- feature_metadata %>% mutate(sequencing_lane = NULL, Age = NULL, Country = NULL)
  # pivot feature_metadata to long format, before, was multiple metadata columns per row, after this will be one metadata column per row
  feature_metadata_longer <- feature_metadata %>% 
    pivot_longer(cols = -c(feature, SampleID, prevalence), names_to = "variable", values_to = "value")
  
  # View(feature_metadata_longer)
  # variable is e.g. Group/Sex, value is e.g. AcuteTyphoid/Male etc.
  prevalence <- feature_metadata_longer %>% 
    group_by(feature, variable, value) %>% 
    summarize(Median_Prevalence = median(prevalence))
  
  # View(prevalence)
  # Return the prevalence data frame
  return(prevalence)
}

run_maaslin <- function(feature_data, metadata, output_root, country, groups_for_analysis, variables_for_analysis, norm, trans, reference_groups){
  ifelse(!dir.exists(output_root), dir.create(output_root), FALSE)
  metadata_to_analyse <- metadata %>% filter(Country == country, Group %in% groups_for_analysis)
  # View(metadata_to_analyse)
  # View(unique(metadata_to_analyse$Group))
  # View(unique(metadata_to_analyse$Sex))
  # View(feature_data)
  # prevalence is a data frame where each row is the prevalence of a feature in a sample, and there is a row for each metadata group that a sample belongs to
  # e.g. feature 1, group 1, prevalence 0.5
  #      feature 1, group 2, prevalence 0.5
  prevalence <- calculate_prevalence(feature_data, metadata, country, groups_for_analysis, variables_for_analysis)
  vars_for_dirname <- paste(variables_for_analysis, collapse = '.')
  output_dir <- file.path(output_root, paste(country, paste(groups_for_analysis, collapse = '_vs_'), vars_for_dirname, sep = '_'))
  # Maaslin2(input_data = feature_data, input_metadata = metadata_to_analyse, analysis_method = "LM", min_prevalence = 0,
  #          normalization  = norm,
  #          transform = trans,
  #          output         = output_dir, 
  #          fixed_effects  = variables_for_analysis,
  #          reference = reference_groups)
  add_prevalence_to_maaslin_output(output_dir, prevalence)
}


combine_maaslins <- function(bangladesh_maaslin, malawi_maaslin){
  # thanks chatgpt!
  combined_df <- bangladesh_maaslin %>%
    inner_join(malawi_maaslin, by = c("feature", 'metadata', 'value'), suffix = c("_bang", "_mal"))
  write_csv(combined_df, "/Users/flashton/Desktop/tmp.csv")
  # Filter the combined data frame based on the conditions for coef > 0
  filtered_df_positive_coef <- combined_df %>%
    filter(
      qval_bang < 0.05 & qval_mal < 0.05 & 
        (coef_bang > 0 & coef_mal > 0)
    )
  
  # Filter the combined data frame based on the conditions for coef < 0
  filtered_df_negative_coef <- combined_df %>%
    filter(
      qval_bang < 0.05 & qval_mal < 0.05 & 
        (coef_bang < 0 & coef_mal < 0)
    )
  
  # Return the two filtered data frames
  return(list(positive_coef = filtered_df_positive_coef, negative_coef = filtered_df_negative_coef, all_features = combined_df))
}


run_combine_maaslins <- function(groups_to_analyse, mwi_variables_for_analysis, bang_variables_for_analysis, maaslin_output_root_folder, analysis_type){
  mwi_vars_for_dirname <- paste(mwi_variables_for_analysis, collapse = '.')
  bang_vars_for_dirname <- paste(bang_variables_for_analysis, collapse = '.')
  
  groups_for_dirname <- paste(groups_to_analyse, collapse = '.')
  
  bang_maaslin_output_dir <- file.path(maaslin_output_root_folder, paste('Bangladesh', paste(groups_to_analyse, collapse = '_vs_'), bang_vars_for_dirname, sep = '_'))
  malawi_maaslin_output_dir <- file.path(maaslin_output_root_folder, paste('Malawi', paste(groups_to_analyse, collapse = '_vs_'), mwi_vars_for_dirname, sep = '_'))
  bang_maaslin <- read_delim(file.path(bang_maaslin_output_dir, "all_results.tsv"), delim = "\t", escape_double = FALSE, trim_ws = TRUE)
  malawi_maaslin <- read_delim(file.path(malawi_maaslin_output_dir, "all_results.tsv"), delim = "\t", escape_double = FALSE, trim_ws = TRUE)
  
  combined_maaslins <- combine_maaslins(bang_maaslin, malawi_maaslin)
  
  combined_maaslins_positive_coef <- combined_maaslins$positive_coef
  combined_maaslins_negative_coef <- combined_maaslins$negative_coef
  if (analysis_type == 'bigmap') {
    combined_maaslins_positive_coef <- combined_maaslins_positive_coef %>% separate_wider_delim(feature, delim = 'Entryname.', names_sep = '', cols_remove = FALSE) %>% separate_wider_delim(feature2, delim = '..OS.', names_sep = '') %>% separate_wider_delim(feature22, delim = '..SMASH', names_sep = '') %>% select(!c(feature1, feature222)) %>% rename(MGC_class = feature21, Species = feature221, feature = featurefeature)
    combined_maaslins_negative_coef <- combined_maaslins_negative_coef %>% separate_wider_delim(feature, delim = 'Entryname.', names_sep = '', cols_remove = FALSE) %>% separate_wider_delim(feature2, delim = '..OS.', names_sep = '') %>% separate_wider_delim(feature22, delim = '..SMASH', names_sep = '') %>% select(!c(feature1, feature222)) %>% rename(MGC_class = feature21, Species = feature221, feature = featurefeature)
  }
  

  # one of these two lines should be hashed out, depending on if all the covars were used for both sites or not
  vars_for_output_dirname <- mwi_vars_for_dirname
  # vars_for_output_dirname <- paste(mwi_vars_for_dirname, 'mwi_only', sep = '_')
  
  #combined_maaslins_positive_coef %>%  kbl() %>% kable_styling()
  write_csv(combined_maaslins_positive_coef, file.path(maaslin_output_root_folder, paste(groups_for_dirname, vars_for_output_dirname, 'combined_maaslins_positive_coef.csv', sep = '.')))
  #combined_maaslins_negative_coef %>%  kbl() %>% kable_styling()
  write_csv(combined_maaslins_negative_coef, file.path(maaslin_output_root_folder, paste(groups_for_dirname, vars_for_output_dirname, 'combined_maaslins_negative_coef.csv', sep = '.')))
}


run_combine_edgeR <- function(groups_for_comparison, bangladesh_covars, malawi_covars){
  comp <- paste(groups_for_comparison[1], 'vs', groups_for_comparison[2], sep = '_')
  bang_covar_initials <- paste(str_sub(bangladesh_covars, 1, 6), sep = '', collapse = '')
  mal_covar_initials <- paste(str_sub(malawi_covars, 1, 6), sep = '', collapse = '')
  
  blantyre_output_path <- file.path(output_folder_blantyre, '5_glm', paste('results_all', comp, mal_covar_initials, 'edgeR.tsv', sep = '.'))
  dhaka_output_path <- file.path(output_folder_dhaka, '5_glm', paste('results_all', comp, bang_covar_initials, 'edgeR.tsv', sep = '.'))
  
  blantyre_output <- read_delim(blantyre_output_path, delim = "\t", escape_double = FALSE,  trim_ws = TRUE)
  dhaka_output <- read_delim(dhaka_output_path, delim = "\t", escape_double = FALSE,  trim_ws = TRUE)
  
  # this is the ridiculous shit you have to do in R to get a list of dataframes.
  to_combine_paths <- c(blantyre_output_path, dhaka_output_path)
  # this is a vec of strings that will be passed to dge_output to give sensible names to the joined output
  # needs to be same order as to_combine_paths
  to_combine_strings_for_join <- c("_mal", "_bang")
  to_combine <- list()
  for (i in seq_along(to_combine_paths)) {
    to_combine[[i]] <- read_delim(to_combine_paths[i], delim = "\t", escape_double = FALSE,  trim_ws = TRUE)
    to_combine[[i]] <- to_combine[[i]] %>% rename(species=...1)
  }
  
  dge_output <- combine_and_compare_edgeRs(to_combine, to_combine_strings_for_join)
  
  #options(scipen = 999)
  #options(scipen = 0) # to switch scientific notation back on
  
  sig_up_for_writing <- dge_output$sig_up %>% select(species, logFC_bang, FDR_bang, logFC_mal, FDR_mal) 
  sig_up_for_writing %>% kbl() %>% kable_styling()
  write_csv(sig_up_for_writing, file.path(combined_output_root, 'dge', paste(the_date, comp, covar_initials, 'sig_up_dge.csv', sep = '.')))
  
  sig_down_for_writing <- dge_output$sig_down %>% select(species, logFC_bang, FDR_bang, logFC_mal, FDR_mal)
  sig_down_for_writing %>% kbl() %>% kable_styling()
  write_csv(sig_down_for_writing, file.path(combined_output_root, 'dge', paste(the_date, comp, covar_initials, 'sig_down_dge.csv', sep = '.')))
  #covar_initials <- paste(str_sub(covars, 1, 6), sep = '', collapse = '')
  #combined_dge_output_folder <- file.path(combined_output_root, paste(covar_initials, 'combined_edgeR'))
}












